{
  "ramblings": [
    {
      "title": "A few thoughts on making this page",
      "text": "A few things I learnt and some thoughts I had while making this page.\nI tried a few different ways to implement the card display and ultimately settled on using scroll to trigger drawing and stashing the cards. At first I tried keeping a container element at a single position and trigger the corresponding card effects when moving above or below certain points and then snap back to the fixed position. This gave the animation a nice elastic bouncing effect but with the different ways scroll is implemented across browsers it was more trouble than it was worth. Touch events were ok, but then scroll events have to be accounted for anyway so might as well ditch everything and just use scroll events for control.\nWhile the card transitions are triggered by scroll events, most of the actual work is done outside of the listener to ensure that the app will not become choppy or unresponsive. Once certain conditions are met an item(async function) is created and added to a queue with the cards to be processed. The queue automatically handles the items added and calls them sequentially, waiting until the current item is finished before calling the next. With this, no matter how many items are added through scrolling, the rate that they are processed will always remain the same. Since everything happening inside a single queue, timing and controlling the flow becomes trivial by adding items into the queue at the desired position.\nMy favourite part of the whole thing is probably the ability to stop the animation by scrolling in the opposite direction, mimicking normal scrolling behaviour. The code for it is really simple yet it just works so well. While the animation might be playing for the 5th card, the index and the queue could be up to the 10th card or higher. By adding a callback to queue items with the index and scroll position at the time they were added, these references can then be use to reset their values back to the card currently being shown, making a seamless transition.\nNavigating between tabs is also done through the same type of queue. Any scripts or special transitions associated with a route can be added to the before and after callback functions, ensuring that they will always have the correct timings without worrying about any race conditions. Each time a route change is pushed to the queue, any queued item that hasn't been process yet will be discarded. This way if any navigation wasn't handle instantly(such as waiting for a transition to finish) only the route that's picked last will be rendered while the UI still remains responsive.\nThe overlapping card effect was surprisingly easy to implement, have one element containing all the details of the card and then have another element that wraps around this element. Set the width of the outer element to be smaller than the width of the card and the browser will take care of the rest. To implement an expanding card effect a bit of JS is needed, the width of each line of cards needs to be calculated so that there's enough space for the card to expand but not enough where an extra card can fit in. This means that the width of the overlapped card needs to be greater than half of the expanded card, otherwise the UI will jump all over the place due to wrapping every time a card expands."
    }
  ]
}